# Project2 SimpleKernel part2
### C core
## 时钟中断处理
时钟中断通过bios_set_timer()设置发生中断的时钟周期数触发。
在main函数中，通过bios_read_fdt()读取了CPU频率，之后通过系统调用sys_get_tick()获得当前时钟周期数，两者相除就可以得到实际时间。
（这主要用于调用sys_sleep()时使用真实时间）

------------

时钟中断触发后，按照中断处理流程保存上下文并传参进入helper，然后根据scause和中断跳转表进入时钟中断的处理程序handle_irq_timer()。
该程序主要完成三件事：
1. 检查是否有可以唤醒的task，将可以唤醒的task唤醒。
2. 设置下一次时钟中断时间。
3. 检查当前task时间片是否用尽，如果用尽，则重新调度。

------------

每个task在被调度时会被分配相同的时间片，与当前时钟相加，得到task终止时钟，存入相应pcb结构体中。
每次时钟中断发生时，则检查当前时钟和task终止时钟，以此判断是否需要重新调度。

------------

设计中存在的问题：
1. 睡眠进程被唤醒后不能立刻执行，只能插入准备队列队头，待当前进程时间片用完后被调度。对于耗时短但紧急性高的突发进程来讲，这样的设计存在不合理之处。
2. 一次只能唤醒一个睡眠进程，后续还有待改进。

------------

## 创建线程
创建线程通过系统调用sys_fork(* void func, arg0, arg1)实现。
该系统调用创建并初始化一个入口地址为给定函数的线程，将其放在等待队列的队尾。函数的参数在进程初始化时被放在栈中储存上下文的a0、a1寄存器的对应位置。当调度该进程执行时，参数被load进a0和a1，然后跳转至函数入口地址开始执行。这一过程与之后的调度过程并无特殊处理，完全和其他进程的初始化、调度等相同，除了需要初始化函数的参数。

------------

测试程序首先初始化一个全局变量数组的值，然后创建两个线程分别对数组求和，最后收集求和结果并相加，得到数组的总求和结果。
线程通过一个全局变量done来告知主程序求和工作已完成，然后进入while(1)循环。
主程序在收到两个进程的done信号前，while(1)循环等待，之后进行收集结果、检验结果、打印结果的工作，然后进入while(1)循环。

------------

设计中存在的问题：
1. 只能传递两个参数，在本测试程序中够用，但应改进为传入一个指向参数的指针，以适用于接收任意多参数的函数。
2. 主程序和线程完成工作后都只能while(1)等待，没有回收工作。
